import{y as s,z as h}from"./index-2a4a3604.js";async function p(){return(await s.get("/projects")).data}async function a(r){if(!r)throw new Error("Project ID is required");return(await s.get(`/projects/${r}`)).data}async function d(r){return(await s.post("/projects",{...r,createdAt:new Date().toISOString(),breakpoints:[],notesText:""})).data}async function c(r,t){if(!r)throw new Error("Project ID is required");return t.notesText!==void 0&&(t.notesText=String(t.notesText)),(await s.put(`/projects/${r}`,t)).data}async function l(r){if(!r)throw new Error("Project ID is required");await s.delete(`/projects/${r}`)}async function j(r,t){if(!r)throw new Error("Project ID is required");const o=[...(await a(r)).breakpoints,t];return c(r,{breakpoints:o})}async function f(r,t,e){if(!r)throw new Error("Project ID is required");const n=[...(await a(r)).breakpoints];return n[t]=e,c(r,{breakpoints:n})}async function P(r,t){if(!r)throw new Error("Project ID is required");const o=(await a(r)).breakpoints.filter((n,i)=>i!==t);return c(r,{breakpoints:o})}async function k(r,t){if(!r)throw new Error("Project ID is required");const e=String(t||"");return c(r,{notesText:e})}const y=h("projects",{state:()=>({projects:[],currentProject:null,loading:!1,error:null}),getters:{sortedProjects:r=>[...r.projects].sort((t,e)=>new Date(e.createdAt)-new Date(t.createdAt)),sortedBreakpoints:r=>!r.currentProject||!r.currentProject.breakpoints?[]:[...r.currentProject.breakpoints].sort((t,e)=>t.time-e.time)},actions:{async fetchProjects(){this.loading=!0,this.error=null;try{this.projects=await p()}catch(r){console.error("Failed to fetch projects:",r),this.error="Failed to load project list"}finally{this.loading=!1}},async fetchProject(r){this.loading=!0,this.error=null;try{this.currentProject=await a(r)}catch(t){console.error(`Failed to fetch project ${r}:`,t),this.error="Failed to load project details"}finally{this.loading=!1}},async addProject(r){this.loading=!0,this.error=null;try{const t=await d(r);return this.projects.push(t),t}catch(t){throw console.error("Failed to create project:",t),this.error="Failed to create project",t}finally{this.loading=!1}},async updateProject(r,t){if(!r)throw this.error="Cannot update project: Missing ID",new Error("Project ID is required");this.loading=!0,this.error=null;try{const e=await c(r,t),o=this.projects.findIndex(n=>n._id===r);return o!==-1&&(this.projects[o]=e),this.currentProject&&this.currentProject._id===r&&(this.currentProject=e),e}catch(e){throw console.error(`Failed to update project ${r}:`,e),this.error="Failed to update project",e}finally{this.loading=!1}},async removeProject(r){if(!r)throw this.error="Cannot delete project: Missing ID",new Error("Project ID is required");this.loading=!0,this.error=null;try{await l(r),this.projects=this.projects.filter(t=>t._id!==r),this.currentProject&&this.currentProject._id===r&&(this.currentProject=null)}catch(t){throw console.error(`Failed to delete project ${r}:`,t),this.error="Failed to delete project",t}finally{this.loading=!1}},async addBreakpoint(r){if(!this.currentProject){this.error="No project selected, cannot add breakpoint";return}if(!this.currentProject._id){this.error="Invalid project: Missing ID";return}this.error=null;try{const t=[...this.currentProject.breakpoints,r];return t.sort((e,o)=>e.time-o.time),this.currentProject&&(this.currentProject.breakpoints=t),j(this.currentProject._id,r).then(e=>{const o=e.breakpoints||[];JSON.stringify(o)!==JSON.stringify(this.currentProject.breakpoints)&&(console.log("Syncing breakpoints with server"),this.currentProject.breakpoints=o);const n=this.projects.findIndex(i=>i._id===this.currentProject._id);n!==-1&&(this.projects[n].breakpoints=this.currentProject.breakpoints)}).catch(e=>{console.error("Background breakpoint sync failed:",e)}),this.currentProject}catch(t){throw console.error("Failed to add breakpoint:",t),this.error="Failed to add breakpoint",t}},async updateBreakpoint(r,t){if(!this.currentProject){this.error="No project selected, cannot update breakpoint";return}if(!this.currentProject._id){this.error="Invalid project: Missing ID";return}this.error=null;try{const e=[...this.currentProject.breakpoints];return e[r]={...e[r],...t},this.currentProject={...this.currentProject,breakpoints:[...e]},f(this.currentProject._id,r,t).then(o=>{const n=o.breakpoints||[];JSON.stringify(n)!==JSON.stringify(this.currentProject.breakpoints)&&(console.log("Syncing breakpoints with server"),this.currentProject={...this.currentProject,breakpoints:[...n]});const i=this.projects.findIndex(u=>u._id===this.currentProject._id);i!==-1&&(this.projects[i]={...this.projects[i],breakpoints:[...this.currentProject.breakpoints]})}).catch(o=>{console.error("Background breakpoint sync failed:",o)}),this.currentProject}catch(e){throw console.error("Failed to update breakpoint:",e),this.error="Failed to update breakpoint",e}},async removeBreakpoint(r){if(!this.currentProject){this.error="No project selected, cannot delete breakpoint";return}if(!this.currentProject._id){this.error="Invalid project: Missing ID";return}this.error=null;try{const t=this.currentProject.breakpoints.filter((e,o)=>o!==r);return this.currentProject&&(this.currentProject.breakpoints=t),P(this.currentProject._id,r).then(e=>{const o=e.breakpoints||[];JSON.stringify(o)!==JSON.stringify(this.currentProject.breakpoints)&&(console.log("Syncing breakpoints with server"),this.currentProject.breakpoints=o);const n=this.projects.findIndex(i=>i._id===this.currentProject._id);n!==-1&&(this.projects[n].breakpoints=this.currentProject.breakpoints)}).catch(e=>{console.error("Background breakpoint sync failed:",e)}),this.currentProject}catch(t){throw console.error("Failed to delete breakpoint:",t),this.error="Failed to delete breakpoint",t}},async updateNotes(r){if(!this.currentProject){this.error="No project selected, cannot update notes";return}if(!this.currentProject._id){this.error="Invalid project: Missing ID";return}this.loading=!0,this.error=null;try{const t=await k(this.currentProject._id,r);this.currentProject=t;const e=this.projects.findIndex(o=>o._id===this.currentProject._id);return e!==-1&&(this.projects[e]=t),t}catch(t){throw console.error("Failed to update notes:",t),this.error="Failed to update notes",t}finally{this.loading=!1}},clearError(){this.error=null}}}),b=(r,t)=>{const e=r.__vccOpts||r;for(const[o,n]of t)e[o]=n;return e};export{b as _,y as u};
